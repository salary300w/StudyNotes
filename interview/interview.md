- [C++基础](#c基础)
  - [```struct```和```class```的区别](#struct和class的区别)
  - [```include```中```<>```和```""```的区别](#include中和的区别)
  - [导入C函数的关键字是什么，C++编译时和C有什么不同？](#导入c函数的关键字是什么c编译时和c有什么不同)
  - [程序从源码到执行文件，预编译、编译、汇编、链接](#程序从源码到执行文件预编译编译汇编链接)
  - [```static```关键字](#static关键字)
  - [函数指针](#函数指针)
  - [静态变量初始化](#静态变量初始化)
  - [nullptr调用成员函数可以吗？为什么？](#nullptr调用成员函数可以吗为什么)
  - [野指针](#野指针)
  - [静态局部变量，全局变量，局部变量的特点，以及使用场景](#静态局部变量全局变量局部变量的特点以及使用场景)
  - [C++传值方式 值传递、引用传递、指针传递](#c传值方式-值传递引用传递指针传递)
  - [说说内联函数和宏函数的区别](#说说内联函数和宏函数的区别)
  - [运算符i++和++i的区别](#运算符i和i的区别)
  - [new和malloc的区别](#new和malloc的区别)
    - [malloc底层实现](#malloc底层实现)
    - [mmap()的原理和应用场景](#mmap的原理和应用场景)
    - [new底层实现](#new底层实现)
  - [const和define的区别](#const和define的区别)
  - [C++中函数指针和指针函数](#c中函数指针和指针函数)
  - [堆和栈的区别](#堆和栈的区别)
  - [C++的内存管理](#c的内存管理)
    - [内存分配方式---栈、堆、代码区、全局/静态存储区、常量存储区](#内存分配方式---栈堆代码区全局静态存储区常量存储区)
    - [常见的内存错误及其对策](#常见的内存错误及其对策)
    - [内存泄漏](#内存泄漏)
    - [malloc和局部变量分配在堆还是栈？](#malloc和局部变量分配在堆还是栈)
    - [进程的内存片段](#进程的内存片段)
  - [什么是内存对齐](#什么是内存对齐)
  - [面向对象的三大特征 封装、继承、多态](#面向对象的三大特征-封装继承多态)
    - [多重继承-菱形继承](#多重继承-菱形继承)
    - [类继承时的访问权限](#类继承时的访问权限)
  - [面向过程和面向对象的区别](#面向过程和面向对象的区别)
  - [构造函数，默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。](#构造函数默认构造函数初始化构造函数拷贝构造函数移动构造函数)
  - [空类的默认生成函数](#空类的默认生成函数)
  - [C++ 类对象的初始化顺序，有多重继承情况下的顺序](#c-类对象的初始化顺序有多重继承情况下的顺序)
  - [深拷贝和浅拷贝](#深拷贝和浅拷贝)
  - [C++多态](#c多态)
  - [重载和重写](#重载和重写)
    - [多态的底层实现：虚函数表](#多态的底层实现虚函数表)
  - [虚析构，为什么不能虚构造](#虚析构为什么不能虚构造)
  - [模板类是在什么时候实现的](#模板类是在什么时候实现的)
  - [深拷贝和浅拷贝](#深拷贝和浅拷贝-1)
  - [C++ 类内可以定义引用数据成员](#c-类内可以定义引用数据成员)
  - [什么是常函数，有什么作用](#什么是常函数有什么作用)
  - [STL](#stl)
    - [vector](#vector)
    - [deque](#deque)
    - [list](#list)
    - [map、set、multimap、multiset](#mapsetmultimapmultiset)
    - [unordered_map、unordered_set、unordered_multimap、 unordered_multiset（hashtable）](#unordered_mapunordered_setunordered_multimap-unordered_multisethashtable)
  - [C++11的新特性](#c11的新特性)
    - [语法上](#语法上)
    - [标准库的扩充](#标准库的扩充)
- [操作系统](#操作系统)
  - [线程池的设计思路](#线程池的设计思路)
  - [软链接和硬链接的区别](#软链接和硬链接的区别)
  - [GDB](#gdb)
  - [大端小端，如何判断大端小端](#大端小端如何判断大端小端)
  - [进程调度算法](#进程调度算法)
  - [抢占式和非抢占式的区别](#抢占式和非抢占式的区别)
  - [操作系统如何申请以及管理内存 虚拟内存的优缺点](#操作系统如何申请以及管理内存-虚拟内存的优缺点)
  - [Linux内核态与用户态](#linux内核态与用户态)
  - [LRU算法及其实现方式](#lru算法及其实现方式)
  - [页表 虚拟内存->物理内存](#页表-虚拟内存-物理内存)
  - [堆栈溢出是什么，会怎么样？](#堆栈溢出是什么会怎么样)
  - [并发和并行](#并发和并行)
  - [进程、线程、协程是什么，区别是什么？](#进程线程协程是什么区别是什么)
    - [进程间切换](#进程间切换)
    - [进程间通信方式](#进程间通信方式)
    - [线程间通信方式](#线程间通信方式)
    - [进程同步方式](#进程同步方式)
    - [进程的状态 创建-就绪-运行-阻塞-终止](#进程的状态-创建-就绪-运行-阻塞-终止)
  - [孤儿进程，僵尸进程，守护进程](#孤儿进程僵尸进程守护进程)
  - [fork-创建子进程](#fork-创建子进程)
  - [互斥锁的机制，互斥锁与读写的区别](#互斥锁的机制互斥锁与读写的区别)
  - [死锁 产生条件 如何解决](#死锁-产生条件-如何解决)
- [计算机网络](#计算机网络)
  - [I/O多路复用](#io多路复用)
    - [select与poll](#select与poll)
    - [select与epoll的区别](#select与epoll的区别)
    - [epoll水平出发与边沿触发](#epoll水平出发与边沿触发)
  - [域名解析过程](#域名解析过程)
  - [TCP 三次握手和四次挥手的过程](#tcp-三次握手和四次挥手的过程)
  - [TCP 和 UDP 的区别](#tcp-和-udp-的区别)
    - [TCP 如何保证有序](#tcp-如何保证有序)
    - [TCP 超时重传](#tcp-超时重传)
    - [TCP 可靠性保证](#tcp-可靠性保证)
    - [滑动窗口](#滑动窗口)
    - [浏览器从输入 URL 到展现页面的全过程](#浏览器从输入-url-到展现页面的全过程)
    - [HTTP 和 HTTPS 的区别](#http-和-https-的区别)
      - [HTTP 的方法](#http-的方法)
      - [HTTP 1.0，1.1，2.0 的主要区别](#http-101120-的主要区别)
      - [HTTP 常见的响应状态码及其含义](#http-常见的响应状态码及其含义)
      - [GET请求和 POST 请求的区别](#get请求和-post-请求的区别)
      - [Cookie 和 Session 的关系和区别](#cookie-和-session-的关系和区别)
      - [HTTPS 的加密与认证过程](#https-的加密与认证过程)
# C++基础
## ```struct```和```class```的区别
- struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；
- struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的。
- 在继承关系中，struct 默认是公有继承，而 class 是私有继承；
- class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。
  
| |C|C++|
|:---:|:---:|:---:|
|成员函数|不能有|可以|
|静态成员|不能有|可以|
|访问控制|默认public，不能修改|public/private/protected|
|继承关系|不可以继承|可从类或其他结构体继承|
|初始化|不能直接初始化数据成员|可以|
|使用方式|需要加上struct关键字|可以省略|
## ```include```中```<>```和```""```的区别
- 尖括号```<>```的头文件是系统文件，双引号```""```的头文件是自定义文件
- 编译器预处理阶段查找头文件的路径不一样。
  - 使用尖括号```<>```的头文件的查找路径：编译器设置的头文件路径-->系统变量。
  - 使用双引号```""```的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。
## 导入C函数的关键字是什么，C++编译时和C有什么不同？
- ```extern "C" int strcmp(const char *s1, const char *s2); //指示这部分代码按C语言进行编译```
- 编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

## 程序从源码到执行文件，预编译、编译、汇编、链接
- 预编译
  - ```#define```宏定义替换
  - 处理条件预编译指令，```#if #ifdef```
  - 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
  - 过滤所有的注释
  - 添加行号和文件名标识
- 编译
  - 词法分析 语法分析 语义分析
  - 代码优化 目标代码生成 目标代码优化
- 汇编
  - 将汇编代码转变成机器可以执行的指令
- 链接
  - 静态链接
    - 接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中
    - 删除静态库不影响程序执行。静态库:win:.lib文件，linux:.a文件
  - 动态链接
    - 执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码
    - 删除动态库程序不可运行。动态库:win:.dll文件，linux:.so文件
## ```static```关键字
- 定义全局静态变量和局部静态变量
  - 在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；
- 定义静态函数
  - 在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；
- 在c++中，static关键字可以用于定义类中的静态成员变量
  - 使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。
- 在c++中，static关键字可以用于定义类中的静态成员函数
  - 与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。
- 静态成员函数
  - **因为静态成员函数不属于任何一个对象，所以不具备this指针，也就无法对一个对象中的非静态成员进行访问。**
## 函数指针
- 函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
- 应用场景：回调（callback）
  - 调用别人提供的 API函数，称为Call；
  - 如果别人的库里面调用我们的函数，就叫Callback；
  - 例如```sort()```函数自定义比较规则；
## 静态变量初始化
- C语言
  - 全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。
- C++
  - 全局或静态对象当且仅当对象首次用到时才进行构造。
- 所在空间:都在静态存储区。
- 生命周期:静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存
## nullptr调用成员函数可以吗？为什么？
- 可以
- 因为在编译时对象就绑定了函数地址，和指针空不空没关系。
- ptr为该类型的指针，在成员函数中的```this=ptr```,成员函数中使用到this，会导致运行出错。
## 野指针
- 指针指向的内存已经释放，指针未及时置空。此时指针的指向位置是不可知的，可能出现非法访问的错误。
- 避免方法
  - 初始化时置空->申请内存后判空->指针释放后置为nullptr
  - 使用智能指针
## 静态局部变量，全局变量，局部变量的特点，以及使用场景
- C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。
  - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。
  - 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
  - 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
  - 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。
- 所在空间：除了局部变量在栈上外，其他都在静态存储区。
- 生命周期： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。
## C++传值方式 值传递、引用传递、指针传递
- 值传递
  - 形参即使在函数体内值发生变化，也不会影响实参的值；
- 引用传递
  - 形参在函数体内值发生变化，会影响实参的值；
- 指针传递
  - 在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；
## 说说内联函数和宏函数的区别
- 宏定义不是函数
- 宏函数在预编译时把宏名用宏体进行替换，没有类型检查，无论对错都直接替换。
- 内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率。在编译的时候会进行类型的检查。
- inline一般应用于比较小的频繁调用的函数，函数前使用```inline```关键字定义。
  - 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
  - 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
## 运算符i++和++i的区别
- 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的
- 效率不同：后置++执行速度比前置的慢
- i++ 不能作为左值，而++i 可以
- 两者都不是原子操作
## new和malloc的区别
- new是操作符，而malloc是函数。
- new在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
- malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
- new可以被重载；malloc不行。
- new分配内存更直接和安全。
- new发生错误抛出异常，malloc返回null。
### malloc底层实现
- 当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。
### mmap()的原理和应用场景
- mmap是一种内存映射文件的方法，将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写页面到对应的文件磁盘上。
- 使用场景
  - 对同一块区域频繁读写操作
  - 可用于实现用户空间和内核空间的高效交互
  - 可提供进程间共享内存及相互通信
  - 可实现高效的大规模数据传输
### new底层实现
- 创建一个新的对象
- 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
- 执行构造函数中的代码（为这个新对象添加属性）
- 返回新对象
## const和define的区别
- const生效于编译的阶段；define生效于预处理阶段。
- const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
- const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。
## C++中函数指针和指针函数
- 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。
- 写法不同
  ```C++
  int *fun(int x,int y); //指针函数
  int (*fun)(int x,int y); //函数指针
  ```
## 堆和栈的区别
- 堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
- 堆栈缓存方式不同。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
- 堆栈数据结构不同。堆类似数组结构；栈类似栈结构，先进后出。
## C++的内存管理
- 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
### 内存分配方式---栈、堆、代码区、全局/静态存储区、常量存储区
- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
- 堆，由程序员手动申请空间，在程序运行期间均有效。变量需要手动释放，否则只会在程序结束后被回收。
- 代码区，用来存储可执行代码的地方，只读不可写。
- 全局/静态存储区，全局变量和静态变量被分配到同一块内存中。
- 常量存储区，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。
### 常见的内存错误及其对策
- 错误
  - 内存分配未成功，却使用了它。
  - 内存分配虽然成功，但是尚未初始化就引用它。
  - 内存分配成功并且已经初始化，但操作越过了内存的边界。
  - 忘记了释放内存，造成内存泄露。
  - 释放了内存却继续使用它。
- 对策
  - 定义指针时，先初始化为nullptr。
  - malloc或new申请内存之后，应该立即检查指针值是否为nullptr。防止使用指针值为nullptr的内存。
  - 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
  - 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
  - 动态内存的申请与释放必须配对，防止内存泄漏。
  - 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”。
  - 使用智能指针。
### 内存泄漏
- 什么是内存泄漏
  - new和malloc申请资源使用后，没有用delete和free释放；
  - 子类继承父类时，父类析构函数不是虚函数。
  - Windows句柄资源使用后没有释放。
- 怎么检测？
  - 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。
  - 将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。
  - 使用智能指针。
  - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
### malloc和局部变量分配在堆还是栈？
- malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。
### 进程的内存片段
![进程内存](png/section.png)
- 从低地址到高地址，由代码段、数据段、BSS段、堆、共享区、栈等组成。
- 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。
- 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。
- BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。
- 运行时，多出堆区和栈区
  - 堆区：动态申请内存用。堆从低地址向高地址增长。
  - 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。
- 最后还有一个共享区，位于堆和栈之间。
## 什么是内存对齐
- 应用于三种数据类型中：struct/class/union，内存对齐原则有四个
  - 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
  - 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
  - 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
  - sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。
## 面向对象的三大特征 封装、继承、多态
- 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
- 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
- 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
- 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。
### 多重继承-菱形继承
- **多重继承**
  - 多重继承指一个子类有两个或两个以上的父类。```class A：public B,private C，protected D```
  - 多继承形式下的构造函数。```A(形参列表):B(形参列表),C(形参列表),D(形参列表){}```，构造函数的调用顺序与声明派生类继承基类出现的顺序相同；
  - 派生类对象中数据成员的排列形式：首先按照派生类定义形式中基类的声明顺序，将基类成员依次排列，接下来再存放派生类中新添加的数据
- **菱形继承**
  ![菱形继承](png/lingxingjicheng.png)
  - 存在数据的二义性的问题，由于他们间接都有相同的基类导致的。还会有数据冗余浪费内存空间。
  - 使用虚继承解决此问题。引入虚基表。虚基表中存放的共同基类的偏移量，通过偏移量去查找基类。
  ```C++
  class A
  {
  public:
  	int m_a = 1;
  };
  class B :virtual public A
  {
  public:
  	int m_b = 2;
  };
  class C :virtual public A
  {
  public:
  	int m_c = 3;
  };
  class D :public B, public C
  {
  public:
  	int m_d = 4;
  };
  ```
### 类继承时的访问权限
|继承方式|派生类|派生类对象|
|:---:|:---:|:---:|
|public|基类的public、protected成员|基类的public成员|
|protected|基类的public、protected成员|基类的成员都不可访问|
|private|派生类可以访问基类的public、protected成员|基类的成员都不可访问|
## 面向过程和面向对象的区别
- 面向过程：根据业务逻辑从上到下写代码
- 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程
## 构造函数，默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。
- 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。有了有参的构造了，编译器就不提供默认的构造函数。
- 赋值构造函数默认实现的是值拷贝（浅拷贝）。
- 拷贝构造函数
  - 拷贝构造函数的参数必须使用引用传递
  - 如果拷贝构造函数中的参数不是一个引用，那么就相当于采用了传值的方式(pass-by-value)，传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。
- 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。
## 空类的默认生成函数
- 无参的构造函数 在定义类的对象的时候，完成对象的初始化工作。
- 拷贝构造函数 拷贝构造函数用于复制本类的对象
- 赋值运算符 ```Empty& operator = (const Empty& copy)```
- 析构函数（非虚）
## C++ 类对象的初始化顺序，有多重继承情况下的顺序
- 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；
- 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）
- 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；
- 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；
- 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）
- 父类构造函数–>成员类对象构造函数–>自身构造函数，其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序，析构顺序和构造顺序相反。
## 深拷贝和浅拷贝
- 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。
- 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
- 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现
## C++多态
- 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。
## 重载和重写
- 重写：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
- 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
- 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。通过函数重载来实现。
- 动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件
  - 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
  - 通过基类类型的指针或引用来调用虚函数。
### 多态的底层实现：虚函数表
- 当基类中存在虚函数时，基类的对象中会多出一部分内存（4字节）用来存储虚函数表的地址。
- 虚函数表：线性表，本质为动态数组。存放函数指针分别指向本类中虚函数地址。
- 派生类继承时，本身也会有虚函数表，表中元素会继承基类虚函数表的元素。
- 派生类未重写基类中的虚函数：派生类中虚函数表中的函数指针指向基类中的虚函数地址。
- 派生类重写基类中的虚函数：派生类中虚函数表中的函数指针指向本类中的对应虚函数地址。
####虚函数与纯虚函数（抽象类）
- 纯虚函数：不需要对函数进行实现。存在纯虚函数时,其虚函数表不完全，有个空位。
- 虚函数：需要对函数进行实现
- 引入纯虚函数原因
  - 很多情况下基类本身生成对象是不合理的，例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
  - 如果派生类需要实例化对象，必须重新声明基类中的纯虚函数，并且实现。
- 抽象类
  - 带有纯虚函数的类为抽象类。
  - 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
  - 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
  - 抽象类是不能定义对象的。
## 虚析构，为什么不能虚构造
- 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。
  - 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
  - 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。
- 不能虚构造的原因
  - 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。
  - 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
  - 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。
## 模板类是在什么时候实现的
- 模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的
- 模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理
## 深拷贝和浅拷贝
- 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。
- 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
- 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现；
## C++ 类内可以定义引用数据成员
- 遵循以下三个规则：
  - 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
  - 构造函数的形参也必须是引用类型。
  - 不能在构造函数里初始化，必须在初始化列表中进行初始化。
## 什么是常函数，有什么作用
- 类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。
## STL
- 由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
- 容器：一些封装数据结构的模板类。
- 算法：例如```sort()```排序函数。
- 迭代器
  - 在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，容器和算法可以通过迭代器无缝连接。
  - 迭代器失效：
    - 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
    - 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
    - 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。
- 仿函数：需要自定义一些比较规则时使用。
- 适配器：专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
- 空间配制器： 为STL提供空间配置的系统。其中主要工作包括两部分：
  - 对象的创建与销毁；
  - 内存的获取与释放。
### vector
- 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(N)
### deque
- 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(N)
### list
- 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(1)
### map、set、multimap、multiset
- 内部实现了一个红黑树，红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。
- 红黑树：特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。
- 时间复杂度：插入: O(logN) 查看: O(logN) 删除: O(logN)
### unordered_map、unordered_set、unordered_multimap、 unordered_multiset（hashtable）
- hashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。
- 插入: O(1)，最坏情况O(N)
- 查看: O(1)，最坏情况O(N)
- 删除: O(1)，最坏情况O(N)
## C++11的新特性
### 语法上
- 统一的初始化方法,使用```{}```
- 成员变量默认初始化，类成员变量可以在定义时就初始化。
- auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
- decltype 求表达式的类型
- 智能指针 shared_ptr
- 空指针 nullptr（原来NULL）
- 基于范围的for循环
- 右值引用和move语义
### 标准库的扩充
- 新增unordered_map
- 正则表达式 ```<regex>```
- Lambda表达式
# 操作系统
## 线程池的设计思路

## 软链接和硬链接的区别
- 定义不同
  - 软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。
  - 硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。
- 限制不同
  - 硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；
  - 软链接可对不存在的文件或目录创建软链接；可交叉文件系统；
- 创建方式不同
  - 硬链接不能对目录进行创建，只可对文件创建；
  - 软链接可对文件或目录创建；
- 影响不同
  - 删除一个硬链接文件并不影响其他有相同 inode 号的文件。
  - 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
## GDB
|命令|作用|
|:---:|:---:|
|quit|退出gdb，结束调试|
|list|查看程序源代码|
|run|程序开始执行|
|break|设置断点|
|watch 条件表达式|条件表达式发生改变时程序就会停下来|
|next|继续执行下一条语句 ，不进入函数内部|
|step|继续执行下一条语句，进入函数内部|
|set follow-fork-mode child/parent|调试子进程/父进程|
## 大端小端，如何判断大端小端
- 小端模式：低的有效字节存储在低的存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式。
- 大端模式：高的有效字节存储在低的存储器地址。大端为网络字节序；KEIL C51则为大端模式。
- 根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储。
  ```C++
  int fun1(){  
    union test{   
        char c;   
        int i; 
    };  
    test t; t.i = 1;  
    //如果是大端，则t.c为0x00，则t.c != 1，反之是小端  
    return (t.c == 1);  
  }  
  ```
## 进程调度算法
- 先来先服务调度算法
  - 每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
- 短作业(进程)优先调度算法
  - 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。
- 高优先级优先调度算法
  - 当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程
- 时间片轮转法
  - 每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
- 多级反馈队列调度算法
  - 综合前面多种调度算法。
## 抢占式和非抢占式的区别
- 非抢占式优先权算法,系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。
- 抢占式优先权调度算法,系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。
## 操作系统如何申请以及管理内存 虚拟内存的优缺点
- 物理内存
  - 物理内存有四个层次，按访问时间从快到慢排序分别是寄存器、高速缓存、主存、磁盘。
  - 内存管理器
    - 主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。
- 什么是虚拟内存
  - 操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。
- 虚拟内存的优点
  - 扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。
  - 内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。
  - 可以实现内存共享，方便进程通信。
  - 可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。
- 虚拟内存的缺点
  - 虚拟内存需要额外构建数据结构，占用空间。
  - 虚拟地址到物理地址的转换，增加了执行时间。
  - 页面换入换出耗时。
  - 一页如果只有一部分数据，浪费内存。
- 申请内存 （使用系统调用）
  - brk
  - mmap
## Linux内核态与用户态
- 内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。
- 什么时候进入内核态：共有三种方式：a、系统调用。b、异常。c、设备中断。其中，系统调用是主动的，另外两种是被动的。
## LRU算法及其实现方式
- LRU算法：LRU算法用于缓存淘汰。思路是将缓存中最近最少使用的对象删除掉
- 实现方式：利用链表和hashmap。
  - 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。
  - 在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
## 页表 虚拟内存->物理内存
- 页表是虚拟内存的概念。操作系统虚拟内存到物理内存的映射表，就被称为页表。
- 在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。进行内存分配时都以页为单位，4G物理内存，只需要8M的映射表即可，一些进程没有使用到的虚拟内存，也并不需要保存映射关系，Linux为大内存设计了多级页表，可以进一步减少了内存消耗。
## 堆栈溢出是什么，会怎么样？
- 堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error。
- 栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error。
## 并发和并行
- 并发：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。
- 并行：对于多个CPU，多个进程同时运行。
## 进程、线程、协程是什么，区别是什么？
- 进程：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。
- 线程：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。
- 协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。
- 区别
  - 一个线程从属于一个进程；一个进程可以包含多个线程。
  - 一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。
  - 进程是系统资源调度的最小单位；线程CPU调度的最小单位。
  - 进程系统开销显著大于线程开销；线程需要的系统资源更少。
  - 进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
  - 进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。
  - 通信方式不一样
  - 进程适应于多核、多机分布；线程适用于多核
### 进程间切换
- 保护被中断进程的处理器现场信息
- 修改被中断进程的进程控制块有关信息，如进程状态等
- 把被中断进程的进程控制块加入有关队列
- 选择下一个占有处理器运行的进程
- 根据被选中进程恢复处理器现场
### 进程间通信方式
- 同个主机之间
  - 管道：有名管道、匿名管道，匿名管道只可应用于有关系的进程之间，例如父子进程。半双工管道。本质为一个文件，通过文件描述符0，1来操作读、写端。
  - 消息量：：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。
  - 信号：通知接收进行的某个时间发生，比如子进程结束后发出SIGCHLD信号。
  - 内存共享：多个进程共享同一款内存空间。
- 不同主机间
  - socket套接字：用于不同主机之间的通信。
  - 消息队列。
### 线程间通信方式
- 临界区：每个线程中访问临界资源的那段代码称为临界区，每次只准许一个线程进入临界区，进入后不允许其他线程进入。
- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- 信号量：计数器，允许多个线程同时访问同一个资源。
- 条件变量：通过条件变量通知操作的方式来保持多线程同步。
- 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。
### 进程同步方式
- 信号量：信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
- 消息队列：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。
### 进程的状态 创建-就绪-运行-阻塞-终止
- 创建态：需要获取资源创建进程管理块
- 就绪态：未获得处理器资源，无法运行。
- 运行态：获得处理器资源，在时间片结束后，进入就绪态。
- 阻塞态：在运行期间，其运行所需的其他资源无法获得，进入阻塞态。
- 终止态：进程结束，进入终止态。
## 孤儿进程，僵尸进程，守护进程
- 孤儿进程：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。
- 僵尸进程：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。
- 如何解决僵尸进程：1、在fork子进程之后我们都要及时使用wait系统调用,当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait。2、使用kill命令。
- 守护进程：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。
- 守护进程实现：使用fork创建子进程并退出父进程，子进程调用setsid()开启新的会话。
## fork-创建子进程
- fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回。
- 对于父进程，fork()函数返回新创建的子进程的PID，对于子进程，fork()函数调用成功会返回0。创建出错，fork()函数返回-1。
## 互斥锁的机制，互斥锁与读写的区别
- 互斥锁机制：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。
- 互斥锁和读写锁：
  - 读写锁区分读者和写者，而互斥锁不区分
  - 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。
## 死锁 产生条件 如何解决
- 死锁：是指多个进程在执行过程中，因争夺资源而造成了互相等待。
- 产生条件
  - 互斥条件：访问临界资源时，进行对分配的资源不允许其他进程访问。
  - 请求保持条件：进程获得资源后，又对其他资源发出请求。
  - 不可剥夺条件：进程已获得的资源，只能自己释放。
  - 环路等待条件：若干进程之间形成一种头尾相连的循环等待资源关系。
- 解决方法
  - 资源一次性分配：只有进程获取到所有所需资源时进入运行态。
  - 资源可剥夺
  - 资源有序分配
# 计算机网络
## I/O多路复用
- select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。
### select与poll
- 会监听socket绑定的所有文件描述符，当有数据需要读取时，会将对应的文件描述符置位，会返回文件描述符置位的个数，需要自己遍历来确定具体操作哪个文件描述符来读取数据。是阻塞函数。每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
### select与epoll的区别
- 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。
- 每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。
- select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。
### epoll水平出发与边沿触发
- 水平触发下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；
- 边缘触发下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。
## 域名解析过程
- 在浏览器中输入域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
- 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
- 如果hosts和本地DNS解析器都没有，则会找TCP/IP参数中设置的首选DNS服务器，进行查询。
- 最终本地DNS就把请求发至13台根DNS。
## TCP 三次握手和四次挥手的过程
  ![三次握手](png/three_shakehand.png)
- 第一次握手：建立连接时，客户端向服务器发送SYN(连接请求/接收 报文段)包（seq(发送的第一个字节的序号)=x），请求建立连接，等待确认；
- 第二次握手：服务端收到客户端的SYN包，回一个ACK(确认报文段)包（ACK=x+1）确认收到，同时发送一个SYN包（seq=y）给客户端；
- 第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK=y+1）告诉服务端已经收到
  ![四次挥手](png/four_shakehand.png)
- 客户端发送FIN包（FIN=1)给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据
- 服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕
- 服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接
- 客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接
## TCP 和 UDP 的区别
- TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的
- TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
- TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。
- TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
- TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。
- TCP面向的是字节流的服务，UDP面向的是报文的服务。
### TCP 如何保证有序
- 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。
### TCP 超时重传
- TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。
### TCP 可靠性保证
- TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。
- 最大消息长度
  - 在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。
- 滑动窗口控制
  - 实现不用等待确认包就发送下一个数据包，窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。
- 拥塞控制-慢启动
  - TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。
  - 慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。
### 滑动窗口
- 滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。TCP的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。
- 我们可以假设窗口的大小是1，也是就每次只能发送一个数据，并且发送方只有接受方对这个数据进行确认了以后才能发送下一个数据。如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。
### 浏览器从输入 URL 到展现页面的全过程
- 输入地址
- 浏览器查找域名的 IP 地址
- 浏览器向 web 服务器发送一个 HTTP 请求
- 服务器的永久重定向响应
- 服务器处理请求
- 服务器返回一个 HTTP 响应
- 浏览器显示 HTML
- 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
### HTTP 和 HTTPS 的区别
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
#### HTTP 的方法
|方法|作用|
|:---:|:---:|
|GET|用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器|
|POST|用于传输信息给服务器，主要功能与GET方法类似，推荐使用POST方式|
|PUT|传输文件，报文主体中包含文件内容，保存到对应URI位置|
|HEAD|一般用于验证URI是否有效|
|DELETE|删除文件，与PUT方法相反，删除对应URI位置的文件|
|OPTIONS|查询相应URI支持的HTTP方法|
#### HTTP 1.0，1.1，2.0 的主要区别
- 1.0
  - 默认不支持长连接，需要设置keep-alive参数指定
  - 强缓存expired、协商缓存last-modified\if-modified-since 有一定的缺陷
- 1.1
  - 默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请求在一个Tcp中是串行的)
  - 增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化
- 2.0
  - 多路复用，一个Tcp中多个http请求是并行的 (雪碧图、多域名散列等优化手段http/2中将变得多余)
  - 二进制格式编码传输
  - 使用HPACK算法做header压缩
  - 服务端推送
#### HTTP 常见的响应状态码及其含义
|响应状态码|含义|
|:---:|:---:|
|1XX|信息类状态码（表示接收请求状态处理）|
|2XX|成功状态码（表示请求正常处理完毕）|
|3XX|重定向（表示需要进行附加操作，已完成请求）|
|4XX|客户端错误（表示服务器无法处理请求）|
|5XX|服务器错误状态码（表示服务器处理请求的时候出错）|
#### GET请求和 POST 请求的区别
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET在浏览器回退时是无害的，而POST会再次提交请求。
#### Cookie 和 Session 的关系和区别
- Cookie与Session都是会话的一种方式。
- cookie数据存放在客户的浏览器上，session数据放在服务器上。
- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗   考虑到安全应当使用session。
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能   考虑到减轻服务器性能方面，应当使用COOKIE。
- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
- 典型使用场景比如“购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建Cookie/Session来获取这些信息。
#### HTTPS 的加密与认证过程
- 客户端在浏览器中输入一个https网址，然后连接到server的443端口 采用https协议的server必须有一套数字证书（一套公钥和密钥） 首先server将证书（公钥）传送到客户端 客户端解析证书，验证成功，则生成一个随机数（私钥），并用证书将该随机数加密后传回server server用密钥解密后，获得这个随机值，然后将要传输的信息和私钥通过某种算法混合在一起（加密）传到客户端 客户端用之前的生成的随机数（私钥）解密服务器端传来的信息
- 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。
用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。