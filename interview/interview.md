- [面试](#面试)
  - [```struct```和```class```的区别](#struct和class的区别)
  - [```include```中```<>```和```""```的区别](#include中和的区别)
  - [导入C函数的关键字是什么，C++编译时和C有什么不同？](#导入c函数的关键字是什么c编译时和c有什么不同)
  - [程序从源码到执行文件，预编译、编译、汇编、链接](#程序从源码到执行文件预编译编译汇编链接)
  - [```static```关键字](#static关键字)
  - [函数指针](#函数指针)
  - [静态变量初始化](#静态变量初始化)
  - [nullptr调用成员函数可以吗？为什么？](#nullptr调用成员函数可以吗为什么)
  - [野指针](#野指针)
  - [静态局部变量，全局变量，局部变量的特点，以及使用场景](#静态局部变量全局变量局部变量的特点以及使用场景)
  - [C++传值方式 值传递、引用传递、指针传递](#c传值方式-值传递引用传递指针传递)
  - [说说内联函数和宏函数的区别](#说说内联函数和宏函数的区别)
  - [运算符i++和++i的区别](#运算符i和i的区别)
  - [new和malloc的区别](#new和malloc的区别)
    - [malloc底层实现](#malloc底层实现)
    - [new底层实现](#new底层实现)
  - [const和define的区别](#const和define的区别)
  - [C++中函数指针和指针函数](#c中函数指针和指针函数)
  - [堆和栈的区别](#堆和栈的区别)
  - [C++的内存管理](#c的内存管理)
    - [内存分配方式---栈、堆、自由存储区、全局/静态存储区、常量存储区](#内存分配方式---栈堆自由存储区全局静态存储区常量存储区)
    - [常见的内存错误及其对策](#常见的内存错误及其对策)
    - [内存泄漏](#内存泄漏)
    - [malloc和局部变量分配在堆还是栈？](#malloc和局部变量分配在堆还是栈)
    - [进程的内存片段](#进程的内存片段)
  - [什么是内存对齐](#什么是内存对齐)
  - [面向对象的三大特征 封装、继承、多态](#面向对象的三大特征-封装继承多态)
    - [多重继承-菱形继承](#多重继承-菱形继承)
    - [类继承时的访问权限](#类继承时的访问权限)
  - [面向过程和面向对象的区别](#面向过程和面向对象的区别)
  - [重载和重写](#重载和重写)
  - [构造函数，默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。](#构造函数默认构造函数初始化构造函数拷贝构造函数移动构造函数)
  - [空类的默认生成函数](#空类的默认生成函数)
  - [C++ 类对象的初始化顺序，有多重继承情况下的顺序](#c-类对象的初始化顺序有多重继承情况下的顺序)
  - [深拷贝和浅拷贝](#深拷贝和浅拷贝)
  - [C++多态](#c多态)
    - [多态的底层实现：虚函数表](#多态的底层实现虚函数表)
  - [虚析构，为什么不能虚构造](#虚析构为什么不能虚构造)
  - [模板类是在什么时候实现的](#模板类是在什么时候实现的)
  - [深拷贝和浅拷贝](#深拷贝和浅拷贝-1)
  - [C++ 类内可以定义引用数据成员](#c-类内可以定义引用数据成员)
  - [什么是常函数，有什么作用](#什么是常函数有什么作用)
  - [STL](#stl)
    - [vector](#vector)
    - [deque](#deque)
    - [list](#list)
    - [map、set、multimap、multiset](#mapsetmultimapmultiset)
    - [unordered_map、unordered_set、unordered_multimap、 unordered_multiset（hashtable）](#unordered_mapunordered_setunordered_multimap-unordered_multisethashtable)
  - [C++11的新特性](#c11的新特性)
    - [语法上](#语法上)
    - [标准库的扩充](#标准库的扩充)
  - [操作系统](#操作系统)
    - [软链接和硬链接的区别](#软链接和硬链接的区别)
    - [GDB](#gdb)
    - [大端小端，如何判断大端小端](#大端小端如何判断大端小端)
    - [进程调度算法](#进程调度算法)
    - [抢占式和非抢占式的区别](#抢占式和非抢占式的区别)
    - [操作系统如何申请以及管理内存 虚拟内存的优缺点](#操作系统如何申请以及管理内存-虚拟内存的优缺点)
    - [Linux内核态与用户态](#linux内核态与用户态)
    - [LRU算法及其实现方式](#lru算法及其实现方式)
    - [页表 虚拟内存->物理内存](#页表-虚拟内存-物理内存)
    - [堆栈溢出是什么，会怎么样？](#堆栈溢出是什么会怎么样)
    - [并发和并行](#并发和并行)
    - [进程、线程、协程是什么，区别是什么？](#进程线程协程是什么区别是什么)
    - [孤儿进程，僵尸进程](#孤儿进程僵尸进程)
# 面试
## ```struct```和```class```的区别
- struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；
- struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的。
- 在继承关系中，struct 默认是公有继承，而 class 是私有继承；
- class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。
  
| |C|C++|
|:---:|:---:|:---:|
|成员函数|不能有|可以|
|静态成员|不能有|可以|
|访问控制|默认public，不能修改|public/private/protected|
|继承关系|不可以继承|可从类或其他结构体继承|
|初始化|不能直接初始化数据成员|可以|
|使用方式|需要加上struct关键字|可以省略|
## ```include```中```<>```和```""```的区别
- 尖括号```<>```的头文件是系统文件，双引号```""```的头文件是自定义文件
- 编译器预处理阶段查找头文件的路径不一样。
  - 使用尖括号```<>```的头文件的查找路径：编译器设置的头文件路径-->系统变量。
  - 使用双引号```""```的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。
## 导入C函数的关键字是什么，C++编译时和C有什么不同？
- ```extern "C" int strcmp(const char *s1, const char *s2); //指示这部分代码按C语言进行编译```
- 编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

## 程序从源码到执行文件，预编译、编译、汇编、链接
- 预编译
  - ```#define```宏定义替换
  - 处理条件预编译指令，```#if #ifdef```
  - 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
  - 过滤所有的注释
  - 添加行号和文件名标识
- 编译
  - 词法分析 语法分析 语义分析
  - 代码优化 目标代码生成 目标代码优化
- 汇编
  - 将汇编代码转变成机器可以执行的指令
- 链接
  - 静态链接
    - 接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中
    - 删除静态库不影响程序执行。静态库:win:.lib文件，linux:.a文件
  - 动态链接
    - 执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码
    - 删除动态库程序不可运行。动态库:win:.dll文件，linux:.so文件
## ```static```关键字
- 定义全局静态变量和局部静态变量
  - 在变量前面加上static关键字。初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；
- 定义静态函数
  - 在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用；
- 在c++中，static关键字可以用于定义类中的静态成员变量
  - 使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。
- 在c++中，static关键字可以用于定义类中的静态成员函数
  - 与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间。
- 静态成员函数
  - **因为静态成员函数不属于任何一个对象，所以不具备this指针，也就无法对一个对象中的非静态成员进行访问。**
## 函数指针
- 函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。
- 应用场景：回调（callback）
  - 调用别人提供的 API函数，称为Call；
  - 如果别人的库里面调用我们的函数，就叫Callback；
  - 例如```sort()```函数自定义比较规则；
## 静态变量初始化
- C语言
  - 全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。
- C++
  - 全局或静态对象当且仅当对象首次用到时才进行构造。
- 所在空间:都在静态存储区。
- 生命周期:静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存
## nullptr调用成员函数可以吗？为什么？
- 可以
- 因为在编译时对象就绑定了函数地址，和指针空不空没关系。
- ptr为该类型的指针，在成员函数中的```this=ptr```,成员函数中使用到this，会导致运行出错。
## 野指针
- 指针指向的内存已经释放，指针未及时置空。此时指针的指向位置是不可知的，可能出现非法访问的错误。
- 避免方法
  - 初始化时置空->申请内存后判空->指针释放后置为nullptr
  - 使用智能指针
## 静态局部变量，全局变量，局部变量的特点，以及使用场景
- C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。
  - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。
  - 静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
  - 局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
  - 静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。
- 所在空间：除了局部变量在栈上外，其他都在静态存储区。
- 生命周期： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。
## C++传值方式 值传递、引用传递、指针传递
- 值传递
  - 形参即使在函数体内值发生变化，也不会影响实参的值；
- 引用传递
  - 形参在函数体内值发生变化，会影响实参的值；
- 指针传递
  - 在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；
## 说说内联函数和宏函数的区别
- 宏定义不是函数
- 宏函数在预编译时把宏名用宏体进行替换，没有类型检查，无论对错都直接替换。
- 内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率。在编译的时候会进行类型的检查。
- inline一般应用于比较小的频繁调用的函数，函数前使用```inline```关键字定义。
  - 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
  - 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
## 运算符i++和++i的区别
- 赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的
- 效率不同：后置++执行速度比前置的慢
- i++ 不能作为左值，而++i 可以
- 两者都不是原子操作
## new和malloc的区别
- new是操作符，而malloc是函数。
- new在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
- malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
- new可以被重载；malloc不行。
- new分配内存更直接和安全。
- new发生错误抛出异常，malloc返回null。
### malloc底层实现
- 当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。
### new底层实现
- 创建一个新的对象
- 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
- 执行构造函数中的代码（为这个新对象添加属性）
- 返回新对象
## const和define的区别
- const生效于编译的阶段；define生效于预处理阶段。
- const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
- const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。
## C++中函数指针和指针函数
- 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。
- 写法不同
  ```C++
  int *fun(int x,int y); //指针函数
  int (*fun)(int x,int y); //函数指针
  ```
## 堆和栈的区别
- 堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
- 堆栈缓存方式不同。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
- 堆栈数据结构不同。堆类似数组结构；栈类似栈结构，先进后出。
## C++的内存管理
- 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
### 内存分配方式---栈、堆、自由存储区、全局/静态存储区、常量存储区
- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
- 堆，就是那些由new分配的内存块，一般一个new就要对应一个delete。
- 自由存储区，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。
- 全局/静态存储区，全局变量和静态变量被分配到同一块内存中。
- 常量存储区，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。
### 常见的内存错误及其对策
- 错误
  - 内存分配未成功，却使用了它。
  - 内存分配虽然成功，但是尚未初始化就引用它。
  - 内存分配成功并且已经初始化，但操作越过了内存的边界。
  - 忘记了释放内存，造成内存泄露。
  - 释放了内存却继续使用它。
- 对策
  - 定义指针时，先初始化为nullptr。
  - malloc或new申请内存之后，应该立即检查指针值是否为nullptr。防止使用指针值为nullptr的内存。
  - 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
  - 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
  - 动态内存的申请与释放必须配对，防止内存泄漏。
  - 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针”。
  - 使用智能指针。
### 内存泄漏
- 什么是内存泄漏
  - new和malloc申请资源使用后，没有用delete和free释放；
  - 子类继承父类时，父类析构函数不是虚函数。
  - Windows句柄资源使用后没有释放。
- 怎么检测？
  - 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。
  - 将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。
  - 使用智能指针。
  - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
### malloc和局部变量分配在堆还是栈？
- malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。
### 进程的内存片段
![进程内存](png/section.png)
- 从低地址到高地址，由代码段、数据段、BSS段、堆、共享区、栈等组成。
- 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。
- 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。
- BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。
- 运行时，多出堆区和栈区
  - 堆区：动态申请内存用。堆从低地址向高地址增长。
  - 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。
- 最后还有一个共享区，位于堆和栈之间。
## 什么是内存对齐
- 应用于三种数据类型中：struct/class/union，内存对齐原则有四个
  - 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
  - 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
  - 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
  - sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。
## 面向对象的三大特征 封装、继承、多态
- 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
- 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
- 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
- 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。
### 多重继承-菱形继承
- **多重继承**
  - 多重继承指一个子类有两个或两个以上的父类。```class A：public B,private C，protected D```
  - 多继承形式下的构造函数。```A(形参列表):B(形参列表),C(形参列表),D(形参列表){}```，构造函数的调用顺序与声明派生类继承基类出现的顺序相同；
  - 派生类对象中数据成员的排列形式：首先按照派生类定义形式中基类的声明顺序，将基类成员依次排列，接下来再存放派生类中新添加的数据
- **菱形继承**
  ![菱形继承](png/lingxingjicheng.png)
  - 存在数据的二义性的问题，由于他们间接都有相同的基类导致的。还会有数据冗余浪费内存空间。
  - 使用虚继承解决此问题。引入虚基表。虚基表中存放的共同基类的偏移量，通过偏移量去查找基类。
  ```C++
  class A
  {
  public:
  	int m_a = 1;
  };
  class B :virtual public A
  {
  public:
  	int m_b = 2;
  };
  class C :virtual public A
  {
  public:
  	int m_c = 3;
  };
  class D :public B, public C
  {
  public:
  	int m_d = 4;
  };
  ```
### 类继承时的访问权限
|继承方式|派生类|派生类对象|
|:---:|:---:|:---:|
|public|基类的public、protected成员|基类的public成员|
|protected|基类的public、protected成员|基类的成员都不可访问|
|private|派生类可以访问基类的public、protected成员|基类的成员都不可访问|
## 面向过程和面向对象的区别
- 面向过程：根据业务逻辑从上到下写代码
- 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程
## 重载和重写
- 重写：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
- 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
## 构造函数，默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。
- 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。有了有参的构造了，编译器就不提供默认的构造函数。
- 赋值构造函数默认实现的是值拷贝（浅拷贝）。
- 拷贝构造函数
  - 拷贝构造函数的参数必须使用引用传递
  - 如果拷贝构造函数中的参数不是一个引用，那么就相当于采用了传值的方式(pass-by-value)，传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。
- 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。
## 空类的默认生成函数
- 无参的构造函数 在定义类的对象的时候，完成对象的初始化工作。
- 拷贝构造函数 拷贝构造函数用于复制本类的对象
- 赋值运算符 ```Empty& operator = (const Empty& copy)```
- 析构函数（非虚）
## C++ 类对象的初始化顺序，有多重继承情况下的顺序
- 创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；
- 如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）
- 基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；
- 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；
- 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）
- 父类构造函数–>成员类对象构造函数–>自身构造函数，其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序，析构顺序和构造顺序相反。
## 深拷贝和浅拷贝
- 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。
- 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
- 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现
## C++多态
- 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。
- 由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态
- 静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。通过函数重载来实现。
- 动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件
  - 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
  - 通过基类类型的指针或引用来调用虚函数。
### 多态的底层实现：虚函数表
- 当基类中存在虚函数时，基类的对象中会多出一部分内存（4字节）用来存储虚函数表的地址。
- 虚函数表：线性表，本质为动态数组。存放函数指针分别指向本类中虚函数地址。
- 派生类继承时，本身也会有虚函数表，表中元素会继承基类虚函数表的元素。
- 派生类未重写基类中的虚函数：派生类中虚函数表中的函数指针指向基类中的虚函数地址。
- 派生类重写基类中的虚函数：派生类中虚函数表中的函数指针指向本类中的对应虚函数地址。
####虚函数与纯虚函数（抽象类）
- 纯虚函数：不需要对函数进行实现。存在纯虚函数时,其虚函数表不完全，有个空位。
- 虚函数：需要对函数进行实现
- 引入纯虚函数原因
  - 很多情况下基类本身生成对象是不合理的，例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
  - 如果派生类需要实例化对象，必须重新声明基类中的纯虚函数，并且实现。
- 抽象类
  - 带有纯虚函数的类为抽象类。
  - 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。
  - 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。
  - 抽象类是不能定义对象的。
## 虚析构，为什么不能虚构造
- 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。
  - 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
  - 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。
- 不能虚构造的原因
  - 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。
  - 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
  - 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。
## 模板类是在什么时候实现的
- 模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的
- 模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理
## 深拷贝和浅拷贝
- 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。
- 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
- 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现；
## C++ 类内可以定义引用数据成员
- 遵循以下三个规则：
  - 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
  - 构造函数的形参也必须是引用类型。
  - 不能在构造函数里初始化，必须在初始化列表中进行初始化。
## 什么是常函数，有什么作用
- 类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。
## STL
- 由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
- 容器：一些封装数据结构的模板类。
- 算法：例如```sort()```排序函数。
- 迭代器
  - 在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，容器和算法可以通过迭代器无缝连接。
  - 迭代器失效：
    - 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
    - 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
    - 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。
- 仿函数：需要自定义一些比较规则时使用。
- 适配器：专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
- 空间配制器： 为STL提供空间配置的系统。其中主要工作包括两部分：
  - 对象的创建与销毁；
  - 内存的获取与释放。
### vector
- 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(N)
### deque
- 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(N)
### list
- 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
- 时间复杂度：插入: O(N) 查看: O(1) 删除: O(1)
### map、set、multimap、multiset
- 内部实现了一个红黑树，红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。
- 红黑树：特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。
- 时间复杂度：插入: O(logN) 查看: O(logN) 删除: O(logN)
### unordered_map、unordered_set、unordered_multimap、 unordered_multiset（hashtable）
- hashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。
- 插入: O(1)，最坏情况O(N)
- 查看: O(1)，最坏情况O(N)
- 删除: O(1)，最坏情况O(N)
## C++11的新特性
### 语法上
- 统一的初始化方法,使用```{}```
- 成员变量默认初始化，类成员变量可以在定义时就初始化。
- auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
- decltype 求表达式的类型
- 智能指针 shared_ptr
- 空指针 nullptr（原来NULL）
- 基于范围的for循环
- 右值引用和move语义
### 标准库的扩充
- 新增unordered_map
- 正则表达式 ```<regex>```
- Lambda表达式
## 操作系统
### 软链接和硬链接的区别
- 定义不同
  - 软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。
  - 硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。
- 限制不同
  - 硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；
  - 软链接可对不存在的文件或目录创建软链接；可交叉文件系统；
- 创建方式不同
  - 硬链接不能对目录进行创建，只可对文件创建；
  - 软链接可对文件或目录创建；
- 影响不同
  - 删除一个硬链接文件并不影响其他有相同 inode 号的文件。
  - 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
### GDB
|命令|作用|
|:---:|:---:|
|quit|退出gdb，结束调试|
|list|查看程序源代码|
|run|程序开始执行|
|break|设置断点|
|watch 条件表达式|条件表达式发生改变时程序就会停下来|
|next|继续执行下一条语句 ，不进入函数内部|
|step|继续执行下一条语句，进入函数内部|
|set follow-fork-mode child/parent|调试子进程/父进程|
### 大端小端，如何判断大端小端
- 小端模式：低的有效字节存储在低的存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式。
- 大端模式：高的有效字节存储在低的存储器地址。大端为网络字节序；KEIL C51则为大端模式。
- 根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储。
  ```C++
  int fun1(){  
    union test{   
        char c;   
        int i; 
    };  
    test t; t.i = 1;  
    //如果是大端，则t.c为0x00，则t.c != 1，反之是小端  
    return (t.c == 1);  
  }  
  ```
### 进程调度算法
- 先来先服务调度算法
  - 每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
- 短作业(进程)优先调度算法
  - 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。
- 高优先级优先调度算法
  - 当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程
- 时间片轮转法
  - 每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
- 多级反馈队列调度算法
  - 综合前面多种调度算法。
### 抢占式和非抢占式的区别
- 非抢占式优先权算法,系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。
- 抢占式优先权调度算法,系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。
### 操作系统如何申请以及管理内存 虚拟内存的优缺点
- 物理内存
  - 物理内存有四个层次，按访问时间从快到慢排序分别是寄存器、高速缓存、主存、磁盘。
  - 内存管理器
    - 主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。
- 什么是虚拟内存
  - 操作系统为每一个进程分配一个独立的地址空间，但是虚拟内存。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。
- 虚拟内存的优点
  - 扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。
  - 内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。
  - 可以实现内存共享，方便进程通信。
  - 可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。
- 虚拟内存的缺点
  - 虚拟内存需要额外构建数据结构，占用空间。
  - 虚拟地址到物理地址的转换，增加了执行时间。
  - 页面换入换出耗时。
  - 一页如果只有一部分数据，浪费内存。
- 申请内存 （使用系统调用）
  - brk
  - mmap
### Linux内核态与用户态
- 内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。
- 什么时候进入内核态：共有三种方式：a、系统调用。b、异常。c、设备中断。其中，系统调用是主动的，另外两种是被动的。
### LRU算法及其实现方式
- LRU算法：LRU算法用于缓存淘汰。思路是将缓存中最近最少使用的对象删除掉
- 实现方式：利用链表和hashmap。
  - 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。
  - 在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
### 页表 虚拟内存->物理内存
- 页表是虚拟内存的概念。操作系统虚拟内存到物理内存的映射表，就被称为页表。
- 在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。进行内存分配时都以页为单位，4G物理内存，只需要8M的映射表即可，一些进程没有使用到的虚拟内存，也并不需要保存映射关系，Linux为大内存设计了多级页表，可以进一步减少了内存消耗。
### 堆栈溢出是什么，会怎么样？
- 堆溢出：比如不断的new 一个对象，一直创建新的对象，而不进行释放，最终导致内存不足。将会报错：OutOfMemory Error。
- 栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error。
### 并发和并行
- 并发：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。
- 并行：对于多个CPU，多个进程同时运行。
### 进程、线程、协程是什么，区别是什么？
- 进程：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。
- 线程：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。
- 协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。
- 区别
  - 一个线程从属于一个进程；一个进程可以包含多个线程。
  - 一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。
  - 进程是系统资源调度的最小单位；线程CPU调度的最小单位。
  - 进程系统开销显著大于线程开销；线程需要的系统资源更少。
  - 进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
  - 进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。
  - 通信方式不一样
  - 进程适应于多核、多机分布；线程适用于多核
### 孤儿进程，僵尸进程
- 孤儿进程：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。
- 僵尸进程：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。
- 如何解决僵尸进程：1、在fork子进程之后我们都要及时使用wait系统调用,当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait。2、使用kill命令。